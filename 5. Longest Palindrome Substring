class Solution {
public:
    string longestPalindrome(string s) {
        if(s.size() < 2) {return s;}
        pair<int, int> best_even=make_pair(1,0);
        pair<int, int> best_odd=make_pair(0,0);
        queue<pair<int, int>> candidates;
        for(int i=0; i< s.size(); i++){candidates.push(make_pair(i,i));}
        for(int i=0; i< s.size()-1; i++){
            if(s[i]==s[i+1]){candidates.push(make_pair(i,i+1)); best_even=make_pair(i,i+1);}
        }
        
        while(!candidates.empty()){
            pair<int, int> range = candidates.front();
            candidates.pop();
            if(range.first-1 >= 0 && range.second+1< s.size() && s[range.first-1] == s[range.second+1]){
                pair<int, int> newrange = make_pair(range.first-1, range.second+1);
                if((range.second - range.first )%2==0 && newrange.second - newrange.first > best_odd.second - best_odd.first){
                    best_odd = newrange;
                }
                if((range.second-range.first)%2==1 && newrange.second-newrange.first> best_even.second- best_even.first){
                    best_even = newrange;
                }
                candidates.push(newrange);
            }
        }
        pair<int, int> best = (best_odd.second - best_odd.first > best_even.second-best_even.first)? best_odd: best_even;
        //cout<<"best even"<<best_even.first<<","<<best_even.second<<endl;
        //cout<<"best odd"<<best_odd.first<<","<<best_odd.second<<endl;
        return s.substr(best.first, best.second - best.first+1);
    }
};
