#include <iostream>
#include <vector>
#include <map>
#include <set>
using namespace std;
 
class Solution {
public:
    int countComponents(int n, vector<pair<int, int> >& edges) {
        //check input validity
        //corner case
        if(edges.size() ==0) {return n;} 
        //actual code
        if(n ==0) {return 1;} 
        map<int, int> NodeToComponent;
        //map<int, set<int> > ComponentToSet;
        for(int i=0; i< n; i++) {
            NodeToComponent[i] = i;
            //set<int> temp; temp.insert(i); ComponentToSet[i] = temp;
        }   
        for(int i=0; i< edges.size(); i++){
            int f1 = edges[i].first;
            int f2 = edges[i].second;
            int f1_setID = NodeToComponent[f1];
            int f2_setID = NodeToComponent[f2];
            if (f1_setID == f2_setID) {continue;}
            else // merge two sets into f1's set
            {   
            //set<int> s1 = ComponentToSet[f1_setID];
            //set<int> s2 = ComponentToSet[f2_setID];
            //for(set<int>::iterator it= s2.begin(); it!= s2.end(); ++it) {
            //    ComponentToSet[f1_setID].insert(*it);
            //} 
            //ComponentToSet.erase(f2_setID);
            for(map<int, int>::iterator it= NodeToComponent.begin(); it!= NodeToComponent.end(); ++it){
                if(it->second == f2_setID){
                    it->second = f1_setID;
                }   
            }   
            }   
        }   
        set<int> ids;
        for(map<int, int>::iterator it= NodeToComponent.begin(); it!= NodeToComponent.end(); ++it) {
            ids.insert(it->second);
        }   
        return ids.size();
        //return ComponentToSet.size();
    }   
    
};
