bool comparex(vector<int>& b1, vector<int>& b2) {return b1[0]< b2[0];}
bool comparey(vector<int>& b1, vector<int>& b2) {return b1[1]< b2[1];}
class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        int rec_begin_x = numeric_limits<int>::max(); int rec_end_x = numeric_limits<int>::min();
        int rec_begin_y = numeric_limits<int>::max(); int rec_end_y = numeric_limits<int>::min();
        for(const auto& bbox: rectangles){
            rec_begin_x = min(bbox[0], rec_begin_x);
            rec_end_x = max(bbox[2], rec_end_x);
            rec_begin_y = min(bbox[1], rec_begin_y);
            rec_end_y = max(bbox[3], rec_end_y);
        }   
        map<int, vector<vector<int> > > x_sorted;
        for(int x=rec_begin_x; x< rec_end_x; x++){
            x_sorted[x] = vector<vector<int> >();
        }   
        for(const auto& bbox: rectangles){
            x_sorted[bbox[0]].push_back(bbox);
        }  
       
        map<int, int> range_map;
        
        for(int i=rec_begin_x; i< rec_end_x; i++){
            auto it = x_sorted[i];
            int xmin = numeric_limits<int>::max();
            for(const auto& bbox: it){
                xmin = min(xmin, bbox[2]);
            }   
            if(it.empty()) {xmin = i;}
            for(const auto& bbox: it) {
                if(bbox[2] > xmin) {
                // fracure big polygons
                    int xini = xmin; int xend = bbox[2]; int yini = bbox[1]; int yend=bbox[3];
                  
                    x_sorted[xini].push_back({xini, yini, xend, yend});
                }   
            }   
            
            range_map[i] = xmin- i;
        } 
     
        vector<int> pts;
        for(int x=0; x< rec_end_x- rec_begin_x; x++){ 
            //cout<<"x="<<x<<endl;
            if(!x_sorted[rec_begin_x+x].empty()){
            pts.push_back(rec_begin_x + x); }
        }
        //cout<<"pts.size="<<pts.size()<<endl;
        //for(const auto& it: range_map){
        //    cout<<"range map "<<it.first<<","<<it.second<<endl;
        //}
        if(pts.empty()) {cout<<"pts empty"<<endl; return false;}
        if(pts[0] != rec_begin_x) {cout<<"pts 0 is not begin"<<endl;return false;}
        for(int i=1;i< pts.size(); i++){
            if(pts[i] != pts[i-1] + range_map[pts[i-1]]){
                //cout<<"pts[i]="<<pts[i]<<",pts[i-1]="<<pts[i-1]<<",range_map[pts[i-1]]="<<range_map[pts[i-1]]<<endl;
                //cout<<"pts does not add up"<<endl; 
                return false;}
        }  
        
        //for(const auto&it: pts) {cout<<it<<endl;}
        for(auto& it: x_sorted){
            if(it.second.empty() && range_map[it.first] == 0) {continue;}
            sort(it.second.begin(), it.second.end(), comparey);
            //cout<<"finish sort, i="<<it.first<<",vector size="<<it.second.size()<<endl;
            // count cur polygons
            if(it.second[0][1]!= rec_begin_y) {
                //cout<<"it.second[0][1]="<<it.second[0][1]<<",begin y="<<rec_begin_y<<endl;
                cout<<"begin does not meet"<<endl;
                return false;}
            for(size_t i=1; i< it.second.size(); i++){
                if(it.second[i][1] != it.second[i-1][3]) { 
                    cout<<"middle does not meet"<<endl;
                    return false;}
            }   
            if(it.second[it.second.size()-1][3] != rec_end_y ) {
                cout<<"end does not meet"<<endl;return false;}
        }   
        return true;
    }   
};
